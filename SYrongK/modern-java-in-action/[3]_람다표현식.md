# 람다

Java 8의 새로운 기능이다.

💡 익명함수를 단순화해서 간결하게 사용할 수 있게 한 함수로, 메서드의 파라미터로 전달할 수 있다.


## 람다의 특징

이름이 없으므로 **`익명`**의 특성을 가지고 있고

메서드처럼 파라미터 리스트와, body, return type, 예외 리스트를 포함시키고 있지만, 특정 클래스에 종속되지 않으므로 **`함수`**라고 부른다.

또, 람다 표현식을 메서드 인수로 **`전달`**하거나 변수로 저장할 수 있어 **`간결성`**을 가졌다.

기술적으로 자바 8 이전엔 할 수 없었던 기능을 제공하는 것은 아니지만, 동작 파라미터를 이용할 때 익명 클래스와 같은 번거로운 코드들은 간결하게 만들어준다는 점이 큰 장점이다.

## 람다 표현식 구조

메서드처럼 파라미터 리스트, 람다 바디, return type으로 구성되어 있다.

```java
(람다 파라미터 a, 람다 파라미터 b) -> 람다 바디

(Apple a, Apple b) -> a.getWeight().compareTo(b.getWeight());
```

위의 구조에서 body는 표현식 스타일이나, 블록 스타일로 쓸 수 있다.

```java
(parameters) → expression

(parameters) → {statements;}
```

# 람다 사용하기

람다 표현식은 **`변수`**에 선언하거나, `**함수형 인터페이스**`를 인수로 받는 메서드로 전달할 수 있다.

## 함수형 인터페이스

💡 단 하나의 추상 메서드만 지정하는 인터페이스이다.  
추상 메서드 하나 외에 defaullt 메서드가 여러개 있어도, 함수형 인터페이스가 맞다.


자바 8에서 추가된 함수형 인터페이스를 보면 `@FunctionalInterface` 어노테이션이 달려 있다.

함수형 인터페이스의 추상 메서드 구현을 람다 표현식으로 별도의 클래스를 만들어 구현한 것처럼 전달할 수 있다.

```java
public void test(Function<Apple> function);
```

위 코드의 `function` 자리에 람다 표현식을 넣을 수 있다는 의미이다.

그래서, 람다 표현식을 함수형 인터페이스의 instance로 취급할 수 있다.

### 시그니처와 함수 디스크립터

- 파라미터 리스트를 받는다.
- 특정 return type을 갖는다.
- 필요할 경우 Exception을 던진다.

위의 요소를 갖춘 구조를 `**시그니처**`라고 한다.

함수형 인터페이스의 추상 메서드 시그니처 = 람다 표현식의 시그니처

그리고 시그니처를 서술하는 메서드를 `**함수 디스크립터**`라고 부른다.

```java
(Apple, Apple) -> int
(Apple a, Apple b) -> a.getWeight().compareTo(b.getWeight();
```

위의 예시는 Apple 인스턴스 2개를 파라미터로 받고 return type은 int인 시그니처와 그 시그니처 구조를 따르는 람다식이다.

## 람다식의 유연성

람다식의 중요한 특징 중에 하나는 동일한 시그니처를 가진 함수 디스크립터를 다양하게 쓸 수 있다는 것이다.

```java
(Apple, Apple) -> int
(Apple a, Apple b) -> a.getWeight().compareTo(b.getWeight();
```

위 코드를 예로 들면, 무게를 비교하는 함수 디스크립터를 똑같이 Apple 2개를 인수로 받아 int를 리턴하는 다른 내용으로 구현할 수도 있다는 것이다.

이를 통해 구현하고자 하는 동작을 `더 유연하게` 만들 수 있다.

## java.util.function의 다양한 함수형 인터페이스

다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요하다.

자바8은 `java.util.function` 패키지로 여러가지 함수형 인터페이스를 제공한다.

대표적으로 `**Predicate**`, `**Consumer**`, `**Function**` 같은 함수형 인터페이스가 있다.

### Predicate

T 객체를 인수로 받아서 boolean을 return 하는 test라는 추상 메서드를 정의해 둔 함수형 인터페이스

```java
@FunctionalInterface
public interface Predicate<T> {

	boolean test(T t);
}
```

Predicate<T>의 test 메서드를 클래스를 구현하지 않고도, 람다식으로 간단하게 구현할 수 있다.

### Consumer

T 객체를 인수로 받아서 void를 반환하는 accept라는 추상 메서드를 정의해 둔 함수형 인터페이스

### Function

T 객체를 인수로 받아서 R 객체를 반환하는 추상 메서드 apply를 정의해 둔 함수형 인터페이스

## 오토박싱을 피하게 해주는 함수형 인터페이스

기본형을 참조형으로 변환하는 boxing과정에는 메모리가 소모된다.

함수형 인터페이스는 메모리 소모를 안해도되도록(오토박싱을 하지 않도록) 기본형에 특화된 함수형 인터페이스를 제공한다.

예 : `IntPredicate`, `DoublePredicate`, `IntFunction` …

## 함수형 인터페이스, 람다로 예외 던지기

함수형 인터페이스는 확인된 예외를 던지지 않는다.

따라서, 예외를 던지고 싶으면 예외를 선언하는 `함수형 인터페이스를 새로 만들어서 쓰거나` `람다식을 try-catch 문으로 감싸` 사용해야 한다.

## 대상 형식

컴파일러가 람다 표현식을 읽어들일 때 특정 함수형 인터페이스의 추상메서드를 구현했다는 정보가 명시되어 있지 않아도, 어떤 함수형 인터페이스를 구현한 것인지 파악해낸다.

이렇게 람다식을 더 잘 이해할 수 있도록 도와주는 것에 대상 형식이 있다.

대상 형식 target type 이란 어떤 콘텍스트에서 기대되는 람다 표현식의 형식을 말한다.

```java
AAA<Integer> a = () -> 77;
BBB<Integer> b = () -> 77;
```

위의 코드처럼 `() → 77`이라는 같은 람다식을 쓰더라도 대상 형식이 있기 때문에 다른 함수형 인터페이스로 사용될 수 있다.

또한, 대상 형식을 이용해서 컴파일러가 람다의 시그니처를 추론할 수 있기 때문에, 람다 표현식을 좀 더 간결하게 작성할 수 있다.

```java
List<Apple> redApples = filter(invertory, **Apple apple** -> RED.equals(apple.getColor()));//형식추론 하지 않은 것
List<Apple> redApples = filter(invertory, **apple** -> RED.equals(apple.getColor()));// 형식추론 한 것
```

상황에 따라서 형식을 명시적으로 보여줄지 말지 결정해서 구현하면 된다.

## 지역변수 사용

람다 표현식에선 외부의 변수도 가져다 사용할 수 있는데, 이를 **`람다 캡쳐링`**이라고 한다.

하지만, 지역변수의 인스턴스는 stack 영역에서 관리되는 것으로 스레드와 수명주기를 함께 해야하기 때문에 

람다 표현식에선 final로 선언되어 있거나 final로 선언된 것처럼 사용되는 지역 변수만을 참조할 수 있다.

## 간결하게 참조하기

### 메서드 참조

람다 표현식으로 메서드를 전달할 때, `파라미터 리스트 → 바디`구조 직접 써서 전달하는 것 외에 `**메서드 참조**`를 이용해서 정의해 둔 메서드를 사용하도록 할 수도 있다.

메서드 참조는 특정 메서드만을 호출하는 람다의 축약형이라고 볼 수 있다.

`Apple::getWeight` 메서드 참조를 해서 가독성을 높일 수 있다.

메서드 참조를 사용할 때엔 아직 메서드를 호출한 것이 아니기 때문에 ()가 붙지 않는다.

- 정적 메서드 참조 `Integer::parseInt`
- 다양한 형식의 인스턴스 메서드 참조 `String::length`
- 기존 객체의 인스턴스 메서드 참조 `apple::getWeight`

### 생성자 참조

생성자 또한 마찬가지로 new 키워드를 사용해서 기존 생성자의 참조를 만들 수 있다. `Apple::new`

## 람다 표현식을 조합할 수 있게 도와주는 default 메서드

자바 8의 함수형 인테페이스들은 추상 메서드 외에 다양한 유틸리티 메서드를 포함한다.

그 유틸리티 메서드를 이용해서 여러 간단한 람다 표현식을 조합해서 복잡한 람다 표현식을 만들어 쓰는 것이 가능하다.

그 유틸리티 메서드를 정의한 것이 바로 `**default 메서드**`이다.

정렬 기능을 제공하는 Comparator 함수형 인터페이스를 예로 들면

```java
Comparator<Apple> c = Comparator.comparing(Apple::getWeight);

inventory.sort(comparing(Apple::getWeight).reverse());

```

comparing() 이라는 메서드로 정렬을 시킬 수 있는데, 이를 역정렬시키기 위해서 Comparator가 default 메서드로 제공하고 있는 reverse() 메서드를 추가할 수 있다.

이런 식으로 여러 유틸리티 메서드를 조합해서 다양한 변환 파이프라인을 만들 수 있다.
