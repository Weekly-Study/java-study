# 4장 스트림 소개


💡 ✬ 스트림이란 무엇인가?  
✬ 컬렉션과 스트림  
✬ 내부 반복과 외부 반복  
✬ 중간 연산과 최종 연산


# Stream

자바 8부터 추가된 기능으로,  SQL처럼 선언형으로 컬렉션 데이터를 처리할 수 있게 도와준다.

- **선언형이다.**

질의를 어떻게 구현할지 명시할 필요없이 직관적으로 완성하도록 도와준다.

```java
List<A> a = new ArrayList<>();

List<A> filteringResult = new ArraysList<>();
for (a : A) {
	if (조건) {
		filteringResult.add(a);
	}
}
```

```java
List<A> a = new ArrayList<>();

List<A> filteringResult = a.stream()
												.**filter**(o -> 조건)
												.collect(toList());
```

loop와 if 조건문 등의 제어 블록을 사용해서 직접 원하는 로직을 구현할 필요없이 원하는 조건만 정해두면 된다.

그래서, `선언형`이라고 표현

- **여러 연산 블록을 연결해서 구성한다. (파이프라인)**

```java
소스.stream().filter(필터링 조건).map(추출 조건).sorter(정렬 조건).collect(반환하려는 return type)
```

loop문, if문 혹은 어떤 로직을 filter(), map() 등의 연산 블록으로 조합해서 컬렉션 데이터를 처리하는 `파이프라인`으로 만들 수 있다.

이런 빌딩 블록들은 단일 스레드에서도 병렬 스레드에서도 사용할 수 있게 구현되어 있다.

경우에 따라서, 복잡한 로직을 빌딩 블록으로 표현해내기 때문에 스트림을 비싼 연산이라고 표현한다.

- **쉽게 병렬로 실행시킬 수 있다.**

```java
소스**.parallelStream()**.filter(필터링 조건).map(추출 조건).sorter(정렬 조건).collect(반환하려는 return type)
```

이전엔 병렬을 구현해내려면 `synchronized 등`을 사용해서 직접 병렬을 구현하고 관리해야 했지만, 

스트림은 쉽게 병렬로 동작하도록 지정할 수 있다.

💡 Stream을 사용함으로써 **간결하고 가독성이 좋고, 유연하고, 성능을 높일 수 있다**고 얘기한다.


# 컬렉션과 스트림

- **개념 차이**

스트림은 데이터 처리 연산을 사용하기 위한 소스에서 추출된 연속된 요소라고 보면 된다.

특정 형식의 데이터 집합이라는 것에서 컬렉션과 유사해 보이지만,

**컬렉션**은 메모리에 어떻게 저장할 것인지(자료구조)를 다루는 것이고, 

**스트림**은 저장된 데이터를 가져와서 어떻게 계산할지(처리 연산)를 다루는 것이다.


💡 스트림은 저장된 **`소스`**로 부터 `연속된 요소`를 그대로 가져온 후 어떤 조건들을 넣어서 처리할지 `연산`을 지정할 수 있게 도와준다


스트림과 컬렉션의 가장 큰 차이점은 `데이터를 언제 계산하는지` 이다.

컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. (계산하고 메모리에 저장)

반면 스트림은 요청할 때만 요소를 계산한다. (요청할 때만 원하는 요소를 추출)

- **외부 반복과 내부 반복**

컬렉션 인터페이스를 사용하기 위해선 Iterator나 for-each등으로 직접 요소를 반복시켜야 한다.

이를 `외부 반복`이라고 한다.

스트림 라이브러리는 눈에는 안보이지만 알아서 반복을 처리하고 결과값을 어딘가에 저장한다.

이를 `내부 반복`이라고 한다.

```java
List<String> names = menu.stream()
												.map(Dish::getName)
												.collect(toList());
```

- **병렬**

내부 반복을 씀으로서 작업을 병렬로 처리하거나 다양한 순서로 처리하게 할 수 있다.

외부 반복으로 병렬처리를 수행하려면, 직접 병렬을 구현하고 직접 관리해야 한다는 번거로움이 있다.

- **요소를 한 번만 가져올 수 있다.**

비슷한 점 하나는 컬렉션으로 반복자를 사용할 떄와 마찬가지로 스트림도 한 번만 요소를 가져올 수 있다는 것이다.

요소를 한 번 탐색하면 소비된다.

지나친 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

이 때문에 I/O 채널의 데이터 소스라면 소스를 반복사용할 수 있으므로 새로운 스트림을 만들 수 없다.

# 스트림 연산 구조

스트림을 여러 연산들을 조합한 파이프라인으로 구성되는데, 구조는 아래와 같다.

```java
컬렉션.**스트림 얻기()**.**중간연산()**.**중간연산()**.**스트림 닫기()**;

list.**stream()**.**filter(...).map(...).length(5)**.**collect(toList())**;
```

filter, map, sort 같은 연산들은 스트림을 반환해서 연산을 이어서 만들 수 있도록 한다. 이를 `중간 연산`이라고 한다.

collect 등의 연산들은 스트림을 닫으면서 원하는 결과값을 원하는 자료구조로 반환한다. 이를 `최종 연산`이라고 한다.

중간연산들은 그때 그때 실행하지 않고 스트림 파이프라인을 실행하기 전까진 아무 연산도 수행하지 않는다. (`lazy 하다`)

중간연산들을 모아서 최종연산으로 한 번에 처리하기 때문이다.

- 질의를 수행할 컬렉션 같은 데이터 소스
- 스트림 파이프라인을 구성할 중간 연산 연결
- 스트림 파이프ㅏ인을 실행하고 결과를 만들 최종 연산
