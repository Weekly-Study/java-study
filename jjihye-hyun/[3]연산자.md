# 연산자
- 연산자(Operator): 연산을 수행하는 기호(+, -, *, / 등)
- 피연산자(Operand): 연산자의 작업대상(변수, 상수, 리터럴, 수식)
연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 변환한다.

## 연산자의 종류
| 종류 | 연산자 | 설명 |
| :--: | :---: | ---- |
| 산술 연산자 | + - * / % << >> | 사칙연산과 나머지 연산(%) |
| 비교 연산자 | > < >= <= == != | 크고 작음과 같고 다름을 비교 |
| 논리 연산자 | && || ! & | ^ ~ | '그리고(AND)'와 또는(OR)'으로 조건을 연결 |
| 대입 연산자| = | 우변의 값을 좌변에 저장 |
| 기타 | (type) ?: instanceof | 형변환 연산자, 삼항 연산자, instanceof연산자 |

---
## 산술연산자(usual arithmetic conversion)
산술 연산자에는 사칙연산자(+, -, *, /)와 나머지 연산자(%)가 있다.   
### 사칙연산자 사용할 때 주의할 점
- 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다 -> 0으로 나누면 에러 발생함(ArithmeticException)
- 나누기 연산자의 피연산자가 모두 int 타입인 경우, 연산 결과 또한 int 타입으로 소수점 이하는 버려진다. 반올림 하지 않고 버림 한다. => 두 피연산자 중 어느 한쪽으로 실수 형으로 형변환하여 연산한다. 이때 결과 값은 실수행 타입.

### 나머지 연산자 %
나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자이다.
- 주로 짝수, 혹수 또는 배수 검사 등에서 사용된다.
- 나누는 수로 0을 사용할 수 없다.
- 나누는 수로 음수 혀옹되나, 피연산자의 부호가 무시되어 결과는 음수의 절대값으로 나눈 나머지와 결과가 같다.
---
## 비트연산자
비트연산자는 피연산자를 비트단위로 논리연산한다. 피연산자를 이진수로 표현했을 때의 각 자리를 규칙에 따라 연산하고 피연산자로 정수만 허용하고, 실수는 허용하지 않는다.
- |(OR연산자): 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그외에는 0을 얻는다
- &(AND연산자): 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
- ^(XOR연산자): 피연산자의 값이 서로 다를 떄만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
- ~(비트 전환 연산자): 피연산자를 2진수로 표현했을 때 0은 1로, 1은 0으로 바꿈. 논리부정 연산자!와 유사함. 부호가 반대로 변경된다(1의 보수)
- <<>>(쉬프트 연산자): 피연산자의 각자리를 2진수로 표현했을 떄 오른쪽(>>) 또는 왼족(<<)으로 이동한다. 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.
  - x << n 은 x * 2<sup>n</sup>의 결과와 같다.
  - x >> n 은 x / 2<sup>n</sup>의 결과와 같다.
---
## 관계연산자
관계연산자(비교 연산자)는 두 피연산자를 비교하는데 사용되는 연산자이다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 true, false 둘 중 하나이다. 피연산자의 타입이 서로 다를 경우 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다.
### 대소비교 연산자 < > <= =>
- 두 피연산자의 크기를 비교하는 연산자이다.
- 결과 true, false
- 피연산자 타입은 boolean을 제외한 나머지 기본형 자료형에 다 사용할 수 있다. 참조형에는 사용할 수 없다.
### 등가비교 연산자 == !=
- 두 피연산자의 값이 같은지 다른지 비교하는 연산자.
- 피연산자 타입은 기본형, 참조형 모든 자료형에 사용할 수 있다.
  - 기본형의 경우 변수에 저장되어 있는 값이 같은지
  - 참조형의 경우 객체의 주소값을 저장하기 때문에 두개의 피연산자가 같은 객체를 가리키고 있는지
  - 기본형고 참조형을 비교할 수는 없다.
### 문자열의 비교
두 문자열을 비교할 때는 비교연산자 == 대신 eqauls()라는 메서드를 사용해야 한다. 비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐, 문자열의 내용이 같은지 비교하기 위해서는 equals를 사용한다.

```java
String str1 = "abc";
String str2 = new String("abc");

str2 == "abc" // false => 서로 다른 객체이기 때문
str2.equals("abe") // true
```
---
## 논리연산자
논리 연산자는 둘 이상의 조건을 AND 또는 OR로 연결하여 하나의 식으로 표혈할 수 있게 한다. 피연산자 boolean형 또는 boolean형 값을 결과로 하는 조건식만 허용한다.
### &&, ||, !
- &&: AND결합, 두 피연산자가 모두 True일때만 True.
- ||: OR결합, 두 피연산자 중 어느 한쪽만 true여도 true.   
- ! : 논리 부정 연산자. 피연산자가 true이면 false를 false이면 true를 결과로 반환한다. true와 false을 바꿈
**주의점**   
- &&가 ||보다 우선순위가 높다.괄호를 사용하여 우선순위를 명확히 해주는 것이 좋다
### 효율적 연산(short circuit evaluation)
- 같은 조건식이여도 피연산자의 위치에 따라서 연산속도가 달라질 수 있다.
- OR 연산 ||인 경우 두 피연산자 중 어느 한쪽만 ture여도 전체 연산결과가 true이므로 좌측 피연산자가 true이면 우측 피연산자의 값을 평가하지 않는다. => 연산결과가 true일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.
- AND 연산 &&인 경우 어느 한쪽만 false여도 전체 연산결과가 false이므로 좌측 피연산자가 false이면 우측 피연산자는 평가하지 않는다.
---
## instance of
- instanceof는 객체 타입을 확인하는 연산자이다.
- 형변환 가능여부를 확인하며 true / false 로 결과를 반환한다.
- 주로 상속 관계에서 부모객체인지 자식객체인지 확인하는데 사용된다.

```java
class Parent{} 
class Child extends Parent{} 

public class InstanceofTest { 
    public static void main(String[] args){ 
        Parent parent = new Parent(); 
        Child child = new Child(); 
        
        System.out.println( parent instanceof Parent ); // true 
        System.out.println( child instanceof Parent ); // true 
        System.out.println( parent instanceof Child ); // false => 부모클래스가 자식클래스로 형변환 불가능 => 형변환이 불가능한 경우이므로 false
        System.out.println( child instanceof Child ); // true 
        } 
    }
```
---
## assignment (=) operator (대입연산자)
- 대입연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다.
- 오픈쪽 피연산자(rvalue)의 값을 왼쪽 피연산자(lvalue)에 저장한다.
- 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 제일 나중에 수행된다.

### 복합 대입 연산자
대입 연산자는 다른 연산자(op)와 결합하여 op= 와 같은 방식으로 사용할 수 있다. 예) +=, -=
---
## 3항 연산자
조건식, 식1, 식2 모두 세개의 피연산자를 필요로한다. 첫번째 피연산자인 조건식의 평가결과 true이면 식1이 false이면 식2가 연산결과가 된다. 가독성을 높이기 위해 조건식을 괄호로 둘러싸는 경우가 많다.

```java
result = (x > y)? x : y;
```
- 두 연산자의 타입이 다른 경우, 이항 연산자 처럼 산술 변환이 발생한다.
---
## 연산자 우선 순위
식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.   

| 종류 | 결합규칙 | 연산자 |
| :--: | :---: | ---- | 
| 단항 연산자 | <-- | ++ -- + - ~ ! (type) |
| 산술 연산자 | --> | * / % |
| 산술 연산자 | --> | + - |
| 산술 연산자 | --> | << >> |
| 비교 연산자 | --> | < > <= => instanceof |
| 비교 연산자 | --> | == != |
| 논리 연산자 | --> | & |
| 논리 연산자 | --> | ^ |
| 논리 연산자 | --> | | |
| 논리 연산자 | --> | && |
| 논리 연산자 | --> | || |
| 삼항 연산자 | --> | ? : |
| 대입 연산자 | <-- | = += -= *= /= %= <<= =>> &= ^= |= |

* 우선순위 순
- 산술 > 비교 > 논리 > 대입, 대입이 제일 우선순위가 낮아 마지막에 수행됨
- 단항 연산자의 우선순위가 이항 연산자 보다 높다
- 논리 연잔사 중 &(AND) 가 |(OR) 보다 우선순위가 높다
---
## Java 13, switch 연산자
- 기존의 switch문이 변경된것이 아니라 switch라는 연산자가 추가된 것이다.
- break는 더이상 사용할 수 없고 yield가 대신 사용한다.
- 화살표 연산자를 사용할수있다. (case -> A )


```java
//java 12 
		int a= 1;
		int b= 0;
		b = switch(a) {
			case 1->1;
			case 2->2;
			default -> throw new IllegalStateException("예외값:"+a);
		};


// java 13
int result = switch (mode)  {
    case "a", "b":
        yield 1;
    case "c":
        Yield 2;
    case "d", "e", "f":
        Yield 3;
    default:
        Yield -1;
}
```




---
### 참고
- [도서] 자바의 정석
- https://mine-it-record.tistory.com/120
- http://ryeon9445.com/develop/1-java-operator/
- https://velog.io/@tms01365/JAVA%EC%8A%A4%ED%84%B0%EB%94%943%EC%A3%BC%EC%B0%A8-%EC%97%B0%EC%82%B0%EC%9E%90
